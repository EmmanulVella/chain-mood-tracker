"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for MoodTracker.sol:

  - <root>/packages/site/abi/abi/MoodTrackerABI.ts
  - <root>/packages/site/abi/abi/MoodTrackerAddresses.ts
*/
import { MoodTrackerAddresses } from "@/abi/MoodTrackerAddresses";
import { MoodTrackerABI } from "@/abi/MoodTrackerABI";

export type MoodEntryType = {
  timestamp: string;
  emoji: string;
  messageHash: string;
  exists: boolean;
  isDecrypted: boolean;
  clearEmoji?: string;
  clearMessage?: string;
};

export type DecryptedMoodEntryType = {
  handle: string;
  clear: string | bigint | boolean;
};

function getMoodTrackerByChainId(
  chainId: number | undefined
): { abi: typeof MoodTrackerABI.abi; address?: `0x${string}`; chainId?: number; chainName?: string } {
  if (!chainId) {
    return { abi: MoodTrackerABI.abi };
  }

  const entry = MoodTrackerAddresses[chainId.toString() as keyof typeof MoodTrackerAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: MoodTrackerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: MoodTrackerABI.abi,
  };
}

/*
 * Main MoodTracker React hook
 */
export const useMoodTracker = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<(ethersSigner: ethers.JsonRpcSigner | undefined) => boolean>;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [isLoadingMoods, setIsLoadingMoods] = useState<boolean>(false);
  const [userMoods, setUserMoods] = useState<Map<number, MoodEntryType>>(new Map());
  const [decryptedMoods, setDecryptedMoods] = useState<Map<string, DecryptedMoodEntryType>>(new Map());
  const [message, setMessage] = useState<string>("");
  const [emojiOptions, setEmojiOptions] = useState<string[]>([]);

  const moodTrackerRef = useRef<ReturnType<typeof getMoodTrackerByChainId> | undefined>(undefined);
  const isRecordingRef = useRef<boolean>(isRecording);
  const isLoadingMoodsRef = useRef<boolean>(isLoadingMoods);

  //////////////////////////////////////////////////////////////////////////////
  // MoodTracker Contract
  //////////////////////////////////////////////////////////////////////////////

  const moodTracker = useMemo(() => {
    const c = getMoodTrackerByChainId(chainId);
    moodTrackerRef.current = c;

    if (!c.address) {
      setMessage(`MoodTracker deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Deployment Check
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!moodTracker) {
      return undefined;
    }
    return (Boolean(moodTracker.address) && moodTracker.address !== ethers.ZeroAddress);
  }, [moodTracker]);

  //////////////////////////////////////////////////////////////////////////////
  // Load Emoji Options
  //////////////////////////////////////////////////////////////////////////////

  const loadEmojiOptions = useCallback(async () => {
    if (!moodTracker.address || !ethersReadonlyProvider) {
      return;
    }

    try {
      const contract = new ethers.Contract(
        moodTracker.address,
        moodTracker.abi,
        ethersReadonlyProvider
      );

      const emojiCount = await contract.getEmojiCount();
      const emojis = [];

      for (let i = 0; i < emojiCount; i++) {
        const emoji = await contract.getEmoji(i);
        emojis.push(emoji);
      }

      setEmojiOptions(emojis);
    } catch (error) {
      console.error("Failed to load emoji options:", error);
    }
  }, [moodTracker.address, moodTracker.abi, ethersReadonlyProvider]);

  useEffect(() => {
    loadEmojiOptions();
  }, [loadEmojiOptions]);

  //////////////////////////////////////////////////////////////////////////////
  // Record Mood
  //////////////////////////////////////////////////////////////////////////////

  const canRecord = useMemo(() => {
    return moodTracker.address && instance && ethersSigner && !isRecording;
  }, [moodTracker.address, instance, ethersSigner, isRecording]);

  const recordMood = useCallback(
    async (emojiIndex: number, message: string) => {
      if (isRecordingRef.current) {
        return;
      }

      if (!moodTracker.address || !instance || !ethersSigner) {
        return;
      }

      isRecordingRef.current = true;
      setIsRecording(true);
      setMessage(`Recording mood...`);

      const run = async () => {
        const contractAddress = moodTracker.address;
        if (!contractAddress) return;

        const isStale = () =>
          moodTrackerRef.current?.address !== moodTracker.address ||
          !sameChain.current(chainId) ||
          !sameSigner.current(ethersSigner);

        try {
          // Create encrypted inputs
          const input = instance.createEncryptedInput(
            contractAddress,
            ethersSigner.address
          );

          input.add8(emojiIndex);

          // Hash the message for privacy (we'll store hash on-chain)
          const messageHash = ethers.keccak256(ethers.toUtf8Bytes(message));
          input.add256(BigInt(messageHash));

          // Encrypt the inputs
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage(`Recording cancelled`);
            return;
          }

          setMessage(`Submitting transaction...`);

          const contract = new ethers.Contract(
            contractAddress,
            moodTracker.abi,
            ethersSigner
          );

          const tx = await contract.recordMood(
            enc.handles[0], // emojiIndex
            enc.handles[1], // messageHash
            enc.inputProof,
            enc.inputProof
          );

          setMessage(`Waiting for confirmation...`);

          const receipt = await tx.wait();

          setMessage(`Mood recorded successfully!`);

          // Refresh user's moods
          await loadUserMoods(ethersSigner.address);

        } catch (error) {
          console.error("Failed to record mood:", error);
          setMessage(`Failed to record mood: ${error}`);
        } finally {
          isRecordingRef.current = false;
          setIsRecording(false);
        }
      };

      run();
    },
    [moodTracker.address, moodTracker.abi, instance, ethersSigner, chainId, sameChain, sameSigner]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Load User Moods
  //////////////////////////////////////////////////////////////////////////////

  const loadUserMoods = useCallback(
    async (userAddress: string, days: number = 7) => {
      if (isLoadingMoodsRef.current) {
        return;
      }

      if (!moodTracker.address || !ethersReadonlyProvider) {
        return;
      }

      isLoadingMoodsRef.current = true;
      setIsLoadingMoods(true);

      try {
        const contract = new ethers.Contract(
          moodTracker.address,
          moodTracker.abi,
          ethersReadonlyProvider
        );

        const today = Math.floor(Date.now() / (1000 * 86400));
        const moods = new Map<number, MoodEntryType>();

        for (let i = 0; i < days; i++) {
          const dayTimestamp = today - i;
          const [timestampHandle, emojiHandle, messageHandle, exists] =
            await contract.getMood(userAddress, dayTimestamp);

          moods.set(dayTimestamp, {
            timestamp: timestampHandle,
            emoji: emojiHandle,
            messageHash: messageHandle,
            exists,
            isDecrypted: false,
          });
        }

        setUserMoods(moods);
      } catch (error) {
        console.error("Failed to load user moods:", error);
      } finally {
        isLoadingMoodsRef.current = false;
        setIsLoadingMoods(false);
      }
    },
    [moodTracker.address, moodTracker.abi, ethersReadonlyProvider]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Mood
  //////////////////////////////////////////////////////////////////////////////

  const canDecrypt = useMemo(() => {
    return moodTracker.address && instance && ethersSigner;
  }, [moodTracker.address, instance, ethersSigner]);

  const decryptMood = useCallback(
    async (dayTimestamp: number) => {
      if (!moodTracker.address || !instance || !ethersSigner) {
        return;
      }

      const contractAddress = moodTracker.address;
      if (!contractAddress) return;

      const moodEntry = userMoods.get(dayTimestamp);
      if (!moodEntry || !moodEntry.exists) {
        return;
      }

      setMessage("Decrypting mood...");

      try {
        const sig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [contractAddress as `0x${string}`],
          ethersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        const handles = [
          { handle: moodEntry.timestamp, contractAddress: contractAddress },
          { handle: moodEntry.emoji, contractAddress: contractAddress },
          { handle: moodEntry.messageHash, contractAddress: contractAddress },
        ];

        const result = await instance.userDecrypt(
          handles,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        // Update decrypted moods
        const newDecryptedMoods = new Map(decryptedMoods);
        handles.forEach((handle, index) => {
          newDecryptedMoods.set(handle.handle, {
            handle: handle.handle,
            clear: result[handle.handle],
          });
        });
        setDecryptedMoods(newDecryptedMoods);

        // Update mood entry with decrypted data
        const updatedMoods = new Map(userMoods);
        const emojiIndex = Number(result[moodEntry.emoji]);
        updatedMoods.set(dayTimestamp, {
          ...moodEntry,
          isDecrypted: true,
          clearEmoji: emojiOptions[emojiIndex] || `Emoji ${emojiIndex}`,
          clearMessage: result[moodEntry.messageHash]?.toString() || "Message hash",
        });
        setUserMoods(updatedMoods);

        setMessage("Mood decrypted successfully!");
      } catch (error) {
        console.error("Failed to decrypt mood:", error);
        setMessage(`Failed to decrypt mood: ${error}`);
      }
    },
    [
      moodTracker.address,
      instance,
      ethersSigner,
      fhevmDecryptionSignatureStorage,
      userMoods,
      decryptedMoods,
      emojiOptions,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Check if user has recorded today
  //////////////////////////////////////////////////////////////////////////////

  const hasRecordedToday = useCallback(async (): Promise<boolean> => {
    if (!moodTracker.address || !ethersReadonlyProvider) {
      return false;
    }

    try {
      const contract = new ethers.Contract(
        moodTracker.address,
        moodTracker.abi,
        ethersReadonlyProvider
      );

      return await contract.hasRecordedToday();
    } catch (error) {
      console.error("Failed to check if recorded today:", error);
      return false;
    }
  }, [moodTracker.address, moodTracker.abi, ethersReadonlyProvider]);

  return {
    contractAddress: moodTracker.address,
    isDeployed,
    canRecord,
    canDecrypt,
    isRecording,
    isLoadingMoods,
    userMoods,
    emojiOptions,
    message,
    recordMood,
    loadUserMoods,
    decryptMood,
    hasRecordedToday,
  };
};
